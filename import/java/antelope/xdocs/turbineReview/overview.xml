<?xml version="1.0"?>
<document>
	<properties>
		<title>	Turbine-Review Users Guide</title>
				<author email="peter@courcoux.biz">Peter Courcoux</author>
		<author email="bgidley@berlios.de">Ben Gidley</author>
	</properties>
	<body>
		<section name ="What is Re-View">
			<p>It is a pluggable component for Turbine 2.3, and 2.4 ( and 
				possibly other web application frameworks in future ) which 
				adds a layer of security and validation to http request 
				parameters and provides a general mechanism for handling 
				validation failure and form redisplay. It is not intrusive and 
				provides a framework for re-usable and customisable validation 
				of parameters.</p>
			<p>Re-View was written to provide a service to examine 
				<strong>every</strong> parameter passed to the application. 
				This is a requirement for some systems which have to pass 
				security vetting. During early use the potential for a simple 
				paradigm for form redisplay became apparent and the service was 
				enhanced to provide this additional functionality.</p>
		</section>
		<section name="Overview">
			<p>Re-View has two modes, DEVELOPER and PRODUCTION.</p>
			<subsection name="Developer Mode">
				<p>In developer mode each parameter passed to the application 
					is read and looked up in its rules map. If the parameter is 
					not found in the map a new entry is created for that 
					parameter. The entry is set such that validation always 
					returns 'true'. If the parameter is found in the rules map, 
					it is validated according to the rules specified.</p>
				<p>This approach allows the component to be 'switched on' for 
					an application and to start building its parameter map 
					without any further work on the part of the developer. You 
					can simply start the Re-View service and ignore it. The 
					default RulesDatastore Service is the XMLRulesDatastore 
					which collects the rules and persists them to xml files. 
					You will be able to see the rules being generated by 
					examining the xml files.</p>
				<p>To add validation, you edit the xml rules files, and restart 
					the service. </p>
			</subsection>
			<subsection name="Production Mode">
				<p>In production mode, each parameter is read as before, and if 
					it is found in the rules map, it is validated according to 
					the rules. However, should the parameter not be found in 
					the map, it is treated as a potential attempted security 
					breach and an exception is thrown. Processing of the 
					request can then be terminated or redirected to an error 
					page as appropriate.</p>
			</subsection>
		</section>
		<section name="Validation failure and form redisplay">
			<p>Re-View provides a convenient mechanism for collecting data 
				about the parameters in a request and making them available in 
				a single object. This object, implementing the 
				ValidationResults interface, has methods to add and retrieve 
				messages for each parameter in the request, and includes 
				methods which make it useful, not only for the validation 
				handled by the Re-View service itself, but for validation which 
				may be handled by the applications own business logic 
				validation layer. </p>
			<p>By saving the ValidationResults object in the HttpSession the 
				object can also be used for general purpose form redisplay, 
				such as redisplaying the parameters entered for a search 
				together with the search results.</p>
		</section>
		<section name="Validation">
			<p>Validation is handled by classes that implement the Validator 
				interface. This interface requires four methods :-</p>
			<source><![CDATA[
	public boolean validate(ParameterParser params, 
                            String key, 
                            ValidationResults validationData) 
                            throws ReviewValidationException;

	public void setArguments(Map args) throws ReviewConfigurationException ;

	public void checkArguments() throws ReviewConfigurationException;

      public Map getArgs();
]]></source>
			<p>The first is used to validate a given parameter. The second is 
				used by the RulesService to set arguments for the validator 
				from the rules. CheckArguments() is called at service start-up 
				time and ensures that the validator has the arguments it 
				requires. For example, a MaxLengthStringValidator may require 
				an argument called maxLength of type int and a 
				StringTooLongMessage of type String. These arguments must be 
				supplied by the developer in the rules file and the checkArgs() 
				method allows for these arguments to be checked at service 
				start-up time. Finally, getArgs() returns the arguments so that 
				other services can read from them if required. If writing a new 
				validator, extending from AbstractValidator will mean that you 
				only need to implement validate() and checkArguments(). </p>
			<p>A few simple validators are provided with the service and it is 
				simple to leverage other validation classes such as those 
				provided by jakarta-commons-validation.</p>
		</section>
		<section name="Fail Early">
			<p>A feature of the service is that it is designed to check all the 
				validation rules, validation classes and all the xml at system 
				start-up. If developers follow recommended practice, which 
				basically means properly implementing the checkArguments() 
				method on any new Validators they write, then the service 
				should, if there is some configuration error, fail on start-up, 
				with an error message indicating the reason for the failure. 
				This design minimises the chance that small breaking changes to 
				xml rules files, (e.g. forgetting to close a tag) will not be 
				discovered until a user makes a possibly rare request.</p>
		</section>
	</body>
</document>